\chapter{Introduction}\label{chap:intro}

An Adaptive Object-Model (AOM) is an architectural style based on metamodeling and object-oriented design that exposes its domain model to the end-user, and aims to create better mechanisms for the evolution and adaption of software systems to their environments.

This document presents a study that shows that the patterns and ideologies described as being part of AOM architectures can be successfully adapted to other architectures, with objectives similar to the original ones.

In this introductory chapter, the background and context of the problem are presented, along with the motivation and objectives. The structure of the document is presented, as well as some typographical conventions used to enhance readability.

\section{Context}\label{sec:context}

Software systems are usually designed with a specific purpose in mind. They rely on a series of requirements which are often very difficult to capture and maintain, as they have a tendency to evolve faster than the implementation. This is caused mainly by the poor understanding by the stakeholders about their needs and expectations about what a software system should be able to do~\cite{PT07}. These situations lead to higher costs in software development, as creating and maintaining software systems is a knowledge intensive task~\cite{AdOdSBD07}. Moreover, most of these system are not static, and have a constant need to evolve in order to adapt themselves to their environment and new business rules, shifting the stakeholders' needs and expectations about these software systems.

In face of these situations, new development methods started to focus more on iterative and incremental approaches, accepting \emph{incompleteness} as part of every software system's development cycle~\cite{WC03}. At the same time, many new systems are being developed with an emphasis on flexibility and run-time configuration~\cite{YJ02}. These approaches present a clear contrast with an up-front, full specification for a software system, which, albeit beneficial for some cases, are impractical in constant evolution scenarios. This may lead to sudden changes in software requirements and, inevitably, refactoring. In many cases, there are deadlines to be met and budgets to adhere to: if the resources are insufficient, these situations often lead to a \textsc{Big Ball Of Mud} --- an ``haphazardly structured, sprawling, sloppy, duct-tape and bailing wire, spaghetti code jungle''\cite{big_ball_of_mud} --- ultimately leading to unmaintainable systems, very costly to modify and adapt to the stakeholders needs~\cite{FY97}.

\section{Motivation and Objectives}\label{sec:goals}

Developing quality software is a costly process. Maintaining, as well as adding new features to these software systems is costly and time-consuming. If the process of shaping an information system is made to be as streamlined as possible, the modification of the system's architecture (model and relation-wise) becomes a simple task of adapting the platform according to the natural evolution of the business rules, environment changes and the users and stakeholders needs.

The type of systems mentioned in \ref{sec:context} have very specific architectures, which allow for the modification of the system model in runtime. While this may not be desirable in every situation --- either because of performance reasons or because the usage of such an architecture could bring an undesirable level of complexity --- part of the logic, ideas and patterns of these meta-architectures could be applied to different types of software architectures in order to achieve similar objectives.

Ruby on Rails is one of the most widely used web development frameworks. It provides a series of tools and conventions that allow a developer to focus on the application design rather than implementation details, as most of that work is automatically handled by the framework itself \cite{rails_quotes}. However, when the kind of aforementioned needs arise in these type of applications, the framework could present itself as a barrier to easily building adaptive software as it is tied to a single architectural pattern (MVC) and a series of conventions that favour using relational databases coupled with \emph{Object-Relational Mapping} (ORM) for data manipulation --- meaning that, in most applications, the database schema is an integral part of the platform design\footnote{The somewhat recent appearance of modern non-relational databases such as MongoDB and CouchDB and others shifted this definition towards the code instead of the database schema. However, Rails initially only supported relational databases such as MySQL, and the usage of non-relational databases is outside the scope of this thesis.}. As such the association of these types of design patterns to a full-stack framework such as Rails presents an interesting challenge: how to effectively and harmoniously combine these apparently different ideologies --- Rails is based on a static, descriptive model and AOMs use data to describe the system --- to take advantage of the best of both worlds.

This project will be applied to the \textit{Escolinhas}~\cite{escolinhas} project, a growing, Portuguese, Ruby On Rails based project, in order to enhance the design and provide the means to easily evolve the platform. Escolinhas aims at sustaining social and collaborative work for children in elementary schools involving students, teachers and parents as its users. With the users demanding better and more adaptable teaching tools, it becomes an excellent case-study application to research, test and apply all the work and discoveries made throughout the course of this thesis.

\section{Report Overview \& Structure}\label{sec:structure}

The rest of this report is structured as follows:\\

\textbf{Chapter \ref{chap:sota}: ``\nameref{chap:sota}'' } reviews the most important methodologies and patterns used to make software as adaptable and maintainable as possible.\\

\textbf{Chapter \ref{chap:problem_statement}: ``\nameref{chap:problem_statement}'' } exposes the problem to be addressed and thoroughly explains it, while explaining its usefulness.\\

\textbf{Chapter \ref{chap:approach_results}: ``\nameref{chap:approach_results}'' } reviews the current design of the platform, and performs a variability analysis of the system, choosing three focus areas. Then, for each one, demonstrates its variability requirements, candidate patterns, the chosen patterns and rationale behind such decisions, implementation details and impact analysis.\\

%\textbf{Chapter \ref{chap:validation}: ``\nameref{chap:validation}'' } validates the work described in Chapter~\ref{chap:approach_results} through various metrics\\ % FIXME

\textbf{Chapter \ref{chap:conclusion}: ``\nameref{chap:conclusion}'' } reviews the project, drawing conclusions about the issues addressed in Chapter \ref{chap:approach_results}. It also provides a summary of contributions and some insights on which future developments have been considered.\\

Some typographical conventions are used throughout the document to improve its readability. Pattern names are displayed with \textsc{Small Caps}. Whenever a class (entity) currently part of the escolinhas.pt is referred, it will be typefaced in \textit{italics}. References and citations appear inside [square brackets] and in \textcolor{blue}{highlight} color. Highlighted text will act as an hyperlink when visualizing this document in a computer.

